"use strict";
var helpers = require("../../node_modules/@parcel/transformer-react-refresh-wrap/lib/helpers/helpers.js");
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
helpers.prelude(module);
try {
  var _s = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$(), _s8 = $RefreshSig$();
  const React = require("react");
  const useEqCache = (eq, a) => {
    _s();
    const memoRef = React.useRef(a);
    if (memoRef.current !== a && !eq(memoRef.current, a)) {
      memoRef.current = a;
    }
    return memoRef.current;
  };
  _s(useEqCache, "FPKR3Wgpr84RLpAeB+51UQn6ph8=");
  exports.reactChildrenToArray = children => React.Children.toArray(children);
  exports.memo_ = React.memo;
  exports.useState_ = _s2((tuple, initialState) => {
    _s2();
    const r = React.useState(initialState);
    const state = r[0];
    const setState = r[1];
    if (!setState.hasOwnProperty("$$reactBasicHooks$$cachedSetState")) {
      setState.$$reactBasicHooks$$cachedSetState = update => () => setState(update);
    }
    return tuple(state, setState.$$reactBasicHooks$$cachedSetState);
  }, "+/Ua/ji3qQQBtT23Rv4x20z7BqQ=");
  exports.useEffect_ = _s3((eq, deps, effect) => {
    _s3();
    const memoizedKey = useEqCache(eq, deps);
    React.useEffect(effect, [memoizedKey]);
  }, "scSkEikl4gRw0HX0Wy8oc66lLag=", false, function () {
    return [useEqCache];
  });
  exports.useEffectAlways_ = _s4(effect => {
    _s4();
    return React.useEffect(effect);
  }, "OD7bBpZva5O2jO+Puf00hKivP7c=");
  exports.useLayoutEffect_ = _s5((eq, deps, effect) => {
    _s5();
    const memoizedKey = useEqCache(eq, deps);
    React.useLayoutEffect(effect, [memoizedKey]);
  }, "8HWwX1ZjtC3w9MAJ4EJFheJ+BB8=", false, function () {
    return [useEqCache];
  });
  exports.useLayoutEffectAlways_ = _s6(effect => {
    _s6();
    return React.useLayoutEffect(effect);
  }, "n7/vCynhJvM+pLkyL2DMQUF0odM=");
  exports.useReducer_ = _s7((tuple, reducer, initialState) => {
    _s7();
    const r = React.useReducer(reducer, initialState);
    const state = r[0];
    const dispatch = r[1];
    if (!dispatch.hasOwnProperty("$$reactBasicHooks$$cachedDispatch")) {
      dispatch.$$reactBasicHooks$$cachedDispatch = action => () => dispatch(action);
    }
    return tuple(state, dispatch.$$reactBasicHooks$$cachedDispatch);
  }, "99d+T+667Js9iHVluFck6d+FQPk=");
  exports.useRef_ = React.useRef;
  exports.readRef_ = ref => ref.current;
  exports.writeRef_ = (ref, a) => {
    ref.current = a;
  };
  exports.useContext_ = React.useContext;
  exports.useEqCache_ = useEqCache;
  exports.useMemo_ = _s8((eq, deps, computeA) => {
    _s8();
    const memoizedKey = useEqCache(eq, deps);
    return React.useMemo(computeA, [memoizedKey]);
  }, "QgENGDZOST2MwssXB8KQZkR/gME=", false, function () {
    return [useEqCache];
  });
  exports.useDebugValue_ = React.useDebugValue;
  exports.unsafeSetDisplayName = (displayName, component) => {
    component.displayName = displayName;
    component.toString = () => displayName;
    return component;
  };
  exports.displayName = component => typeof component === "string" ? component : component.displayName || "[unknown]";
  helpers.postlude(module);
} finally {
  window.$RefreshReg$ = prevRefreshReg;
  window.$RefreshSig$ = prevRefreshSig;
}
